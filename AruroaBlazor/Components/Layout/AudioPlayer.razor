@using Models
@using Services
@implements IDisposable
@inject IJSRuntime JS

@* 
    AudioPlayer.razor - Global audio player shown at bottom of ALL pages
    
    This component:
    1. Listens to GlobalAudioPlayerService for state changes
    2. Controls the actual HTML <audio> element
    3. Shows currently playing song info
    4. Has play/pause, next, previous, volume, progress controls
    
    It is added to MainLayout.razor so it appears on every page
*@

@if (currentSong != null)
{
    <div class="global-audio-player">
        <div class="player-container">

            @* ===== SONG INFO SECTION ===== *@
            <div class="song-info-section">
                <div class="song-title">@currentSong.title</div>
                <div class="song-duration">@FormatTime(currentTime) / @FormatTime(duration)</div>
            </div>

            @* ===== CONTROLS SECTION ===== *@
            <div class="controls-section">

                @* Playback buttons - previous, play/pause, next *@
                <div class="playback-controls">
                    <button class="control-btn" @onclick="Previous" title="Previous">
                        ⏮
                    </button>

                    <button class="control-btn play-btn" @onclick="TogglePlayPause" title="Play/Pause">
                        @if (isPlaying)
                        {
                            <span>⏸</span>
                        }
                        else
                        {
                            <span>▶</span>
                        }
                    </button>

                    <button class="control-btn" @onclick="Next" title="Next">
                        ⏭
                    </button>
                </div>

                @* Progress bar - shows how far through the song we are *@
                <div class="progress-section">
                    <input type="range"
                           class="progress-bar"
                           min="0"
                           max="@duration"
                           value="@currentTime"
                           @oninput="OnProgressChanged" />
                </div>
            </div>

            @* ===== VOLUME SECTION ===== *@
            <div class="volume-section">
                <span class="volume-icon">🔊</span>
                <input type="range"
                       class="volume-slider"
                       min="0"
                       max="100"
                       value="@volumePercent"
                       @oninput="OnVolumeChanged" />
                <span class="volume-label">@volumePercent%</span>
            </div>

            @* ===== QUEUE SECTION ===== *@
            <div class="queue-info">
                @{
                    int queueSize = GlobalAudioPlayerService.GetPlayQueue().Count;
                    int queueIndex = GlobalAudioPlayerService.GetCurrentQueueIndex();

                }

                <span class="queue-label">@(queueIndex + 1) / @queueSize in queue</span>

                @* ===== QUEUE LIST ===== *@
                @{
                    List<Song> queue = GlobalAudioPlayerService.GetPlayQueue();
                    int currentIndex = GlobalAudioPlayerService.GetCurrentQueueIndex();
                }

                @if (queue.Count > 0)
                {
                    <div class="queue-list">
                        @for (int i = 0; i < queue.Count; i++)
                        {
                            int index = i;
                            Song queueSong = queue[index];
                            string activeClass = "";

                            if (index == currentIndex)
                            {
                                activeClass = "queue-item-active";
                            }

                            <div class="queue-item @activeClass" @onclick="() => PlayFromQueue(index)">
                                <span class="queue-item-number">@(index + 1)</span>
                                <span class="queue-item-title">@queueSong.title</span>
                                <button class="queue-item-remove"
                                        @onclick="() => RemoveFromQueue(index)"
                                        @onclick:stopPropagation="true">
                                    ✕
                                </button>
                            </div>
                        }
                    </div>
                }
                <button class="clear-queue-btn" @onclick="ClearQueue" title="Clear Queue">
                    ✕ Clear
                </button>
            </div>
        </div>

        @* 
            The ACTUAL audio element that plays the sound
            controls="false" hides the default browser controls
            We use our own custom controls above instead
            
            The @on events let Blazor know what's happening with the audio:
            - ontimeupdate: fires every second to update progress bar
            - onended: fires when song finishes so we can play next
            - onloadedmetadata: fires when song loads so we know duration
        *@
        <audio id="global-audio-player"
               src="@audioSource"
               @ontimeupdate="OnTimeUpdate"
               @onended="OnSongEnded"
               @onloadedmetadata="OnMetadataLoaded"
               style="display:none">
        </audio>
    </div>
}

<style>
    
    /* Queue list */
    .queue-list {
        max-height: 200px;
        overflow-y: auto;
        border-top: 1px solid rgba(255,255,255,0.2);
        margin-top: 10px;
        padding-top: 10px;
    }

    .queue-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
        font-size: 13px;
        color: rgba(255,255,255,0.8);
    }

        .queue-item:hover {
            background: rgba(255,255,255,0.15);
        }

    .queue-item-active {
        background: rgba(255,255,255,0.25);
        color: white;
        font-weight: 600;
    }

    .queue-item-number {
        min-width: 20px;
        font-size: 11px;
        opacity: 0.7;
    }

    .queue-item-title {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .queue-item-remove {
        background: none;
        border: none;
        color: rgba(255,255,255,0.5);
        cursor: pointer;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 11px;
        transition: all 0.2s;
    }

        .queue-item-remove:hover {
            background: rgba(255,0,0,0.3);
            color: white;
        }

    /* Fixed player at bottom of screen */
    .global-audio-player {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 20px;
        z-index: 9999;
        box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
    }

    .player-container {
        display: flex;
        align-items: center;
        gap: 20px;
        max-width: 1400px;
        margin: 0 auto;
    }

    /* Song info */
    .song-info-section {
        min-width: 200px;
        max-width: 250px;
    }

    .song-title {
        font-weight: 600;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: white;
    }

    .song-duration {
        font-size: 12px;
        opacity: 0.8;
        margin-top: 2px;
    }

    /* Controls */
    .controls-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
    }

    .playback-controls {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .control-btn {
        background: rgba(255,255,255,0.2);
        border: none;
        color: white;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

        .control-btn:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.1);
        }

    .play-btn {
        width: 44px;
        height: 44px;
        font-size: 18px;
        background: rgba(255,255,255,0.3);
    }

    /* Progress bar */
    .progress-section {
        width: 100%;
        max-width: 400px;
    }

    .progress-bar {
        width: 100%;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: rgba(255,255,255,0.3);
        border-radius: 2px;
        outline: none;
        cursor: pointer;
    }

        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }

    /* Volume */
    .volume-section {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 140px;
    }

    .volume-icon {
        font-size: 16px;
    }

    .volume-slider {
        width: 80px;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: rgba(255,255,255,0.3);
        border-radius: 2px;
        outline: none;
        cursor: pointer;
    }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }

    .volume-label {
        font-size: 12px;
        min-width: 35px;
        opacity: 0.9;
    }

    /* Queue info */
    .queue-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        min-width: 100px;
    }

    .queue-label {
        font-size: 11px;
        opacity: 0.8;
    }

    .clear-queue-btn {
        background: rgba(255,255,255,0.15);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
    }

        .clear-queue-btn:hover {
            background: rgba(255,255,255,0.3);
        }

    /* Push page content up so player doesn't cover it */
    :global(body) {
        padding-bottom: 80px;
    }

    /* Responsive */
    @@media (max-width: 768px) {
        .player-container {
            flex-wrap: wrap;
            gap: 10px;
        }

        .song-info-section {
            min-width: 150px;
        }

        .volume-section {
            min-width: 100px;
        }
    }
</style>

@code {
    // Currently playing song (null if nothing playing)
    private Song? currentSong = null;

    // Playback state
    private bool isPlaying = false;

    // Time tracking
    private double currentTime = 0;
    private double duration = 0;

    // Volume (0-100 for the slider display)
    private int volumePercent = 70;

    // The audio source URL (base64 data URL)
    private string audioSource = "";

    // The ID of our audio element in the HTML
    // We use this to tell JavaScript which element to control
    private const string AudioElementId = "global-audio-player";

    // Called when component first initializes
    protected override void OnInitialized()
    {
        GlobalAudioPlayerService.OnStateChanged += OnPlayerStateChanged;
    }

    // Play a specific song from the queue
    private void PlayFromQueue(int index)
    {
        currentTime = 0;
        duration = 0;
        GlobalAudioPlayerService.PlayFromQueue(index);
    }

    // Remove a specific song from the queue
    private void RemoveFromQueue(int index)
    {
        GlobalAudioPlayerService.RemoveFromQueue(index);
        StateHasChanged();
    }

    // Called when global player state changes
    private void OnPlayerStateChanged()
    {
        InvokeAsync(async () =>
        {
            // Remember what was playing before
            Song? previousSong = currentSong;
            bool wasPlaying = isPlaying;

            // Get latest state from service
            currentSong = GlobalAudioPlayerService.GetCurrentSong();
            isPlaying = GlobalAudioPlayerService.GetIsPlaying();
            volumePercent = (int)(GlobalAudioPlayerService.GetVolume() * 100);

            // Check if the song CHANGED
            bool songChanged = false;
            if (previousSong == null && currentSong != null)
            {
                // No song before, now we have one
                songChanged = true;
            }
            else if (previousSong != null && currentSong != null)
            {
                if (previousSong.songID != currentSong.songID)
                {
                    // Different song now
                    songChanged = true;
                }
            }

            // If song changed, update the audio source
            if (songChanged)
            {
                if (currentSong != null && currentSong.audioData != null)
                {
                    audioSource = currentSong.GetAudioSource(currentSong.audioData);
                    duration = currentSong.duration;
                    currentTime = 0;
                }
                else
                {
                    audioSource = "";
                }
            }

            // Tell Blazor to redraw so the <audio> element gets new src
            StateHasChanged();

            // Wait for Blazor to actually update the DOM
            // Then tell JavaScript to play/pause
            await Task.Delay(100);

            if (isPlaying)
            {
                // Tell JavaScript to actually play the audio element
                await JS.InvokeVoidAsync("playAudio", AudioElementId);

                // Set volume too
                double volume = GlobalAudioPlayerService.GetVolume();
                await JS.InvokeVoidAsync("setAudioVolume", AudioElementId, volume);
            }
            else
            {
                // Tell JavaScript to pause
                await JS.InvokeVoidAsync("pauseAudio", AudioElementId);
            }
        });
    }

    // Called every second while audio is playing
    // Gets REAL time from JavaScript instead of guessing
    private async void OnTimeUpdate(EventArgs e)
    {
        // Get the ACTUAL current time from the audio element via JavaScript
        // This is more accurate than our manual increment!
        double realTime = await JS.InvokeAsync<double>("getAudioTime", AudioElementId);
        currentTime = realTime;

        // Update service so it stays in sync
        GlobalAudioPlayerService.SetCurrentTime(currentTime);

        StateHasChanged();
    }

    // Called when audio finishes playing
    private void OnSongEnded(EventArgs e)
    {
        currentTime = 0;
        duration = 0;
        GlobalAudioPlayerService.OnSongEnded();
    }

    // Called when audio file loads
    private void OnMetadataLoaded(EventArgs e)
    {
        if (currentSong != null)
        {
            duration = currentSong.duration;
        }
        StateHasChanged();
    }

    // Called when user drags the progress bar
    private async Task OnProgressChanged(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            double newTime = Convert.ToDouble(e.Value);
            currentTime = newTime;

            // Tell JavaScript to actually seek to this position
            await JS.InvokeVoidAsync("setAudioTime", AudioElementId, newTime);

            // Update service
            GlobalAudioPlayerService.SetCurrentTime(newTime);

            StateHasChanged();
        }
    }

    // Called when user drags the volume slider
    private async Task OnVolumeChanged(ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            int newVolumePercent = Convert.ToInt32(e.Value);
            volumePercent = newVolumePercent;

            // Convert percentage to decimal
            double newVolume = newVolumePercent / 100.0;

            // Tell JavaScript to actually change the volume
            await JS.InvokeVoidAsync("setAudioVolume", AudioElementId, newVolume);

            // Update service
            GlobalAudioPlayerService.SetVolume(newVolume);

            StateHasChanged();
        }
    }

    // Play/pause button clicked
    private async Task TogglePlayPause()
    {
        GlobalAudioPlayerService.TogglePlayPause();
        isPlaying = GlobalAudioPlayerService.GetIsPlaying();

        if (isPlaying)
        {
            await JS.InvokeVoidAsync("playAudio", AudioElementId);
        }
        else
        {
            await JS.InvokeVoidAsync("pauseAudio", AudioElementId);
        }

        StateHasChanged();
    }

    // Next button clicked
    private void Next()
    {
        currentTime = 0;
        duration = 0;
        GlobalAudioPlayerService.PlayNext();
    }

    // Previous button clicked
    private void Previous()
    {
        currentTime = 0;
        GlobalAudioPlayerService.PlayPrevious();
    }

    // Clear queue button clicked
    private async Task ClearQueue()
    {
        currentTime = 0;
        duration = 0;
        audioSource = "";

        // Stop the audio
        await JS.InvokeVoidAsync("pauseAudio", AudioElementId);

        GlobalAudioPlayerService.ClearQueue();
        StateHasChanged();
    }

    // Format seconds into MM:SS display
    private string FormatTime(double seconds)
    {
        int totalSeconds = (int)seconds;
        int min = totalSeconds / 60;
        int sec = totalSeconds % 60;
        return min + ":" + sec.ToString("D2");
    }

    // Clean up when component is destroyed
    public void Dispose()
    {
        GlobalAudioPlayerService.OnStateChanged -= OnPlayerStateChanged;
    }
}