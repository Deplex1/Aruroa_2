@page "/songs"
@using DBL
@using Models
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage

@inject NavigationManager Nav
@inject ProtectedSessionStorage Storage

<link href="css/songs.css" rel="stylesheet" />

<div class="songs-page-wrapper">
    <div class="songs-main-section">
        <div class="page-header">
            <h1>Songs</h1>
        </div>

        <!-- Search Section -->
        <div class="search-section">
            <input placeholder="Search songs..." @bind="searchText" @oninput="OnSearchInput" />
            <button @onclick="Search">Search</button>
            <button @onclick="ClearSearch">Clear</button>
        </div>

        <hr class="divider" />

        @if (songList == null)
        {
            <p class="loading-message">Loading songs...</p>
        }
        else if (songList.Count == 0)
        {
            <p class="no-songs-message">No songs found.</p>
        }
        else
        {
            @for (int i = 0; i < songList.Count; i++)
            {
                Song song = songList[i];

                // Calculate average rating manually
                double total = 0;
                int count = 0;

                for (int j = 0; j < allRatings.Count; j++)
                {
                    if (allRatings[j].songid == song.songID)
                    {
                        total += allRatings[j].rating;
                        count++;
                    }
                }

                double avgRating = 0;
                if (count > 0)
                {
                    avgRating = total / count;
                }

                <div class="song-card">
                    <h3>@song.title</h3>
                    <p class="song-info">Duration: @FormatDuration(song.duration) | Plays: @song.plays | Avg: @avgRating.ToString("0.0") (@count ratings)</p>

                    @if (song.audioData != null)
                    {
                        <div class="custom-audio-player">
                            <audio id="audio-@song.songID"
                                   controls
                                   preload="metadata"
                                   @onended="() => OnSongEnded(song.songID)"
                                   @onplay="() => OnSongStarted(song.songID)">
                                <source src="@song.GetAudioSource(song.audioData)" />
                                Your browser does not support audio.
                            </audio>
                        </div>

                        <div class="action-buttons">
                            <button class="add-to-queue-btn" @onclick="() => AddToQueue(song)">
                                Add to Queue
                            </button>
                        </div>
                    }

                    <!-- Star rating -->
                    <div class="stars-section">
                        <div class="stars">
                            @if (currentUser == null)
                            {
                                @for (int s = 1; s <= 5; s++)
                                {
                                    int currentStar = s;
                                    string starClass = GetStarClassForDisplay(song.songID, currentStar);

                                    <span class="star @starClass disabled">
                                        ★
                                    </span>
                                }
                            }
                            else
                            {
                                @for (int s = 1; s <= 5; s++)
                                {
                                    int currentStar = s;
                                    string starClass = GetStarClass(song.songID, currentStar);

                                    <span class="star @starClass"
                                          @onmouseover="() => OnHover(song.songID, currentStar)"
                                          @onmouseout="() => OnHover(song.songID, 0)"
                                          @onclick="() => OnClick(song.songID, currentStar)">
                                        ★
                                    </span>
                                }
                            }
                        </div>

                        @if (currentUser == null)
                        {
                            <div class="login-notice">
                                Please <a @onclick="GoToLogin">log in</a> to rate songs
                            </div>
                        }
                    </div>
                </div>
            }
        }
    </div>

    <!-- Queue Sidebar -->
    <div class="queue-sidebar">
        <h3>Play Queue</h3>

        <div class="queue-list">
            @if (playQueue.Count == 0)
            {
                <div class="no-queue">
                    No songs in queue. Add songs to start playing!
                </div>
            }
            else
            {
                @for (int i = 0; i < playQueue.Count; i++)
                {
                    Song queueSong = playQueue[i];
                    string queueClass = "";
                    if (currentlyPlayingSongId == queueSong.songID)
                    {
                        queueClass = "playing";
                    }

                    <div class="queue-item @queueClass" @onclick="() => PlayFromQueue(i)">
                        <div class="queue-item-title">@queueSong.title</div>
                        <div class="queue-item-duration">@FormatDuration(queueSong.duration)</div>
                    </div>
                }
            }
        </div>

        @if (playQueue.Count > 0)
        {
            <button class="clear-queue-btn" @onclick="ClearQueue">Clear Queue</button>
        }
    </div>
</div>

@code
{
    // List of all songs displayed on the page
    private List<Song> songList = new List<Song>();

    // List of ALL ratings from database (for calculating averages)
    private List<Rating> allRatings = new List<Rating>();

    // Search text entered by user
    private string searchText = "";

    // Currently logged-in user (null if not logged in)
    private User? currentUser;

    // Play queue management
    private List<Song> playQueue = new List<Song>();
    private int currentlyPlayingSongId = -1;

    // User's personal ratings (songId -> rating value 1-5)
    private Dictionary<int, int> userRatings = new Dictionary<int, int>();

    // Temporary ratings shown when hovering over stars (songId -> star number)
    private Dictionary<int, int> previewRatings = new Dictionary<int, int>();

    // Called after component renders for the first time
    protected override async Task OnAfterRenderAsync(bool first)
    {
        if (first)
        {
            await LoadCurrentUser();
            await LoadAllSongs();
        }
    }

    // Load current user from session storage
    private async Task LoadCurrentUser()
    {
        var result = await Storage.GetAsync<User>("user");
        if (result.Success)
        {
            currentUser = result.Value;
        }
        else
        {
            currentUser = null;
        }
    }

    // Load all songs from database along with all their ratings
    private async Task LoadAllSongs()
    {
        SongDB db = new SongDB();
        songList = await db.SelectAllSongsAsync();

        RatingDB ratingDB = new RatingDB();
        allRatings.Clear();

        // Load all ratings for all songs
        // This is for calculating average ratings displayed to everyone
        for (int i = 0; i < songList.Count; i++)
        {
            List<Rating> songRatings = await ratingDB.GetSongRatingsAsync(songList[i].songID);
            for (int j = 0; j < songRatings.Count; j++)
            {
                allRatings.Add(songRatings[j]);
            }
        }

        // If user is logged in, also load their personal ratings
        if (currentUser != null)
        {
            await LoadUserRatings();
        }

        StateHasChanged();
    }

    // Load the logged-in user's personal ratings
    // These are stored in userRatings dictionary for quick lookup
    private async Task LoadUserRatings()
    {
        if (currentUser == null)
        {
            return;
        }

        RatingDB ratingDB = new RatingDB();
        List<Rating> ratings = await ratingDB.GetUserRatingsAsync(currentUser.userid);

        userRatings.Clear();
        for (int i = 0; i < ratings.Count; i++)
        {
            userRatings[ratings[i].songid] = ratings[i].rating;
        }
    }

    // Called when user types in the search box
    // If they clear the search box, reload all songs
    private async Task OnSearchInput(ChangeEventArgs e)
    {
        searchText = e.Value?.ToString() ?? "";
        if (string.IsNullOrWhiteSpace(searchText))
        {
            await LoadAllSongs();
        }
    }

    // Search for songs based on search text
    // FIXED: No longer reloads all songs after searching!
    private async Task Search()
    {
        SongDB db = new SongDB();
        songList = await db.SearchSongsAsync(searchText.Trim());

        // Reload ratings for the search results
        RatingDB ratingDB = new RatingDB();
        allRatings.Clear();

        for (int i = 0; i < songList.Count; i++)
        {
            List<Rating> songRatings = await ratingDB.GetSongRatingsAsync(songList[i].songID);
            for (int j = 0; j < songRatings.Count; j++)
            {
                allRatings.Add(songRatings[j]);
            }
        }

        StateHasChanged();
    }

    // Clear search and show all songs again
    private async Task ClearSearch()
    {
        searchText = "";
        await LoadAllSongs();
    }

    // Convert duration in seconds to "minutes:seconds" format
    // Example: 125 seconds becomes "2:05"
    private string FormatDuration(int seconds)
    {
        int minutes = seconds / 60;
        int secs = seconds % 60;
        return minutes.ToString() + ":" + secs.ToString("00");
    }

    // ===== QUEUE MANAGEMENT =====

    // Add a song to the play queue
    private void AddToQueue(Song song)
    {
        // Check if song is already in queue
        bool alreadyInQueue = false;
        for (int i = 0; i < playQueue.Count; i++)
        {
            if (playQueue[i].songID == song.songID)
            {
                alreadyInQueue = true;
                break;
            }
        }

        // Only add if not already there
        if (alreadyInQueue == false)
        {
            playQueue.Add(song);
            StateHasChanged();
        }
    }

    // Play a specific song from the queue
    private void PlayFromQueue(int index)
    {
        if (index < 0)
        {
            return;
        }
        if (index >= playQueue.Count)
        {
            return;
        }

        Song songToPlay = playQueue[index];
        currentlyPlayingSongId = songToPlay.songID;
        StateHasChanged();

        // NOTE: Actual audio playback control would require JavaScript interop
        // This just tracks which song should be playing
    }

    // Called when a song starts playing
    // Increments the play count in database
    private void OnSongStarted(int songId)
    {
        currentlyPlayingSongId = songId;

        // Increment play count in background
        Task.Run(async () =>
        {
            SongDB db = new SongDB();
            await db.AddPlayAsync(songId);
        });

        StateHasChanged();
    }

    // Called when a song finishes playing
    // Automatically plays the next song in queue if available
    private void OnSongEnded(int songId)
    {
        // Find current song in queue
        int currentIndex = -1;
        for (int i = 0; i < playQueue.Count; i++)
        {
            if (playQueue[i].songID == songId)
            {
                currentIndex = i;
                break;
            }
        }

        // Play next song if it exists
        if (currentIndex >= 0)
        {
            int nextIndex = currentIndex + 1;
            if (nextIndex < playQueue.Count)
            {
                PlayFromQueue(nextIndex);
            }
            else
            {
                currentlyPlayingSongId = -1;
            }
        }

        StateHasChanged();
    }

    // Clear all songs from the queue
    private void ClearQueue()
    {
        playQueue.Clear();
        currentlyPlayingSongId = -1;
        StateHasChanged();
    }

    // Navigate to login page
    private void GoToLogin()
    {
        Nav.NavigateTo("/login");
    }

    // ===== STAR RATING SYSTEM =====

    // Called when mouse hovers over a star
    // Shows preview of what rating would look like
    void OnHover(int songId, int value)
    {
        if (value > 0)
        {
            previewRatings[songId] = value;
        }
        else
        {
            previewRatings.Remove(songId);
        }
        StateHasChanged();
    }

    // Called when user clicks a star to rate a song
    // Saves the rating to the database
    private async Task OnClick(int songId, int value)
    {
        if (currentUser == null)
        {
            return;
        }

        RatingDB ratingDB = new RatingDB();
        await ratingDB.SaveRatingAsync(currentUser.userid, songId, value);

        // Update local rating dictionary
        userRatings[songId] = value;

        // Also update allRatings list for average calculation
        bool exists = false;
        for (int i = 0; i < allRatings.Count; i++)
        {
            if (allRatings[i].songid == songId && allRatings[i].userid == currentUser.userid)
            {
                allRatings[i].rating = value;
                exists = true;
            }
        }
        if (exists == false)
        {
            allRatings.Add(new Rating
            {
                songid = songId,
                userid = currentUser.userid,
                rating = value,
                daterated = System.DateTime.Now
            });
        }

        StateHasChanged();
    }

    // Determine which CSS class to apply to stars for LOGGED-IN users
    // Shows their personal rating with hover preview
    string GetStarClass(int songId, int starIndex)
    {
        // First check if we are hovering
        if (previewRatings.ContainsKey(songId))
        {
            int hoverValue = previewRatings[songId];
            if (starIndex <= hoverValue)
            {
                return "filled";
            }
            else
            {
                return "gray";
            }
        }

        // If not hovering, check the user's actual rating
        if (userRatings.ContainsKey(songId))
        {
            int userValue = userRatings[songId];
            if (starIndex <= userValue)
            {
                return "filled";
            }
            else
            {
                return "gray";
            }
        }

        // No rating at all, show all gray
        return "gray";
    }

    // Determine which CSS class to apply to stars for NON-LOGGED users
    // Shows the average rating from all users (read-only)
    string GetStarClassForDisplay(int songId, int starIndex)
    {
        // Calculate average rating for this song
        double total = 0;
        int count = 0;

        for (int i = 0; i < allRatings.Count; i++)
        {
            if (allRatings[i].songid == songId)
            {
                total += allRatings[i].rating;
                count++;
            }
        }

        if (count > 0)
        {
            double avgRating = total / count;
            int roundedAvg = (int)Math.Round(avgRating);

            if (starIndex <= roundedAvg)
            {
                return "filled";
            }
            else
            {
                return "gray";
            }
        }

        return "gray";
    }
}